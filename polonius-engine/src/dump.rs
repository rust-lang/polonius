//! Inspect the intermediate results of a series of [`Compuation`](crate::Computation)s.

use contracts::*;

use crate::tuples::{Tuple, TupleIter, TupleVec};

#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct RelationId {
    relation: String,
    unit: String,
}

impl RelationId {
    /// Returns of the id of the unit that generated this data.
    pub fn unit_name(&self) -> &str {
        &self.unit
    }

    /// Returns a string identifying this data.
    pub fn relation_name(&self) -> &str {
        &self.relation
    }
}

/// A proxy object that allows [`Computation`](crate::Computation)s to expose intermediate results
/// for the purpose of debugging.
pub struct Dump<'a> {
    dumpers: Vec<&'a mut dyn Dumper>,
    curr_unit: String,
}

impl<'a> Dump<'a> {
    /// Returns a `Dump` object that will forward data to each [`Dumper`] in the list.
    pub fn new(dumpers: Vec<&'a mut dyn Dumper>) -> Self {
        Self {
            dumpers,
            curr_unit: "[input]".to_owned(),
        }
    }

    /// Marks the start of a computation.
    pub(crate) fn unit_start(&mut self, name: &str) {
        self.curr_unit = name.to_owned();
    }

    /// Marks the end of a computation.
    pub(crate) fn unit_end(&mut self, _name: &str) {}

    fn id(&self, name: impl Into<String>) -> RelationId {
        let unit = self.curr_unit.clone();
        RelationId {
            unit,
            relation: name.into(),
        }
    }

    /// Dumps the contents of the given variable.
    #[requires(var.is_stable())]
    pub fn var<T: Tuple>(&mut self, var: &datafrog::Variable<T>) {
        self.var_mapped(var, |x| *x)
    }

    /// Dumps the contents of the given variable.
    #[requires(var.is_stable())]
    pub fn var_named<T: Tuple>(&mut self, name: impl Into<String>, var: &datafrog::Variable<T>) {
        self.var_named_mapped(name, var, |x| *x)
    }

    /// Dumps the contents of the given variable, but transformed with `f`.
    ///
    /// Useful when the variable is in an unusual order for joins.
    #[requires(var.is_stable())]
    pub fn var_mapped<T, U: Tuple>(&mut self, var: &datafrog::Variable<T>, f: fn(&T) -> U) {
        self.var_named_mapped(var.name(), var, f)
    }

    /// Dumps the contents of the given variable with the provided name, but transformed with `f`.
    ///
    /// Useful when the variable is in an unusual order for joins.
    #[requires(var.is_stable())]
    pub fn var_named_mapped<T, U: Tuple>(
        &mut self,
        name: impl Into<String>,
        var: &datafrog::Variable<T>,
        f: fn(&T) -> U,
    ) {
        let stable = var.stable.borrow();
        let tuples = stable.iter().flat_map(|x| x.iter().map(f));
        self.iter(name, tuples)
    }

    /// Dumps the contents of the given relation.
    pub fn rel_ref<T: Tuple>(&mut self, name: impl Into<String>, tuples: &datafrog::Relation<T>) {
        self.vec_ref(name, &tuples.elements);
    }

    /// Dumps the contents of the given relation, but takes ownership of that relation.
    pub fn rel<T: Tuple>(&mut self, name: impl Into<String>, tuples: datafrog::Relation<T>) {
        self.vec(name, tuples.elements);
    }

    /// Dumps the contents of the given vector.
    pub fn vec_ref<T: Tuple>(&mut self, name: impl Into<String>, tuples: &Vec<T>) {
        let id = self.id(name);
        for dumper in self.dumpers.iter_mut() {
            dumper.dump_vec_ref(&id, tuples)
        }
    }

    /// Dumps the contents of the given vector, but takes ownership of that vector.
    pub fn vec<T: Tuple>(&mut self, name: impl Into<String>, tuples: Vec<T>) {
        let id = self.id(name);

        for dumper in self.dumpers.iter_mut().filter(|d| !d.prefer_vec_owned(&id)) {
            dumper.dump_vec_ref(&id, &tuples)
        }

        // Pass ownership of the `Vec` to the first dumper that wants it.

        let mut owned_dumpers = self.dumpers.iter_mut().filter(|d| d.prefer_vec_owned(&id));
        let first_owned = owned_dumpers.next();

        for dumper in owned_dumpers {
            dumper.dump_vec_ref(&id, &tuples);
        }

        if let Some(first_owned) = first_owned {
            first_owned.dump_vec_owned(&id, Box::new(tuples));
        }
    }

    /// Dumps the contents of the given iterator.
    pub fn iter<'it, T: Tuple>(
        &mut self,
        name: impl Into<String>,
        tuples: impl 'it + Clone + Iterator<Item = T>,
    ) {
        let id = self.id(name);
        for dumper in self.dumpers.iter_mut() {
            dumper.dump_iter(&id, Box::new(tuples.clone()))
        }
    }
}

/// Introspect the relations generated by a series of computations.
pub trait Dumper {
    /// Dumps the contents of the given [`TupleIter`].
    fn dump_iter(&mut self, id: &RelationId, tuples: Box<dyn TupleIter<'_> + '_>);

    /// Returns `true` if this `Dumper` is more efficient when given ownership of `tuples`.
    fn prefer_vec_owned(&self, _id: &RelationId) -> bool {
        false
    }

    /// Dumps the contents of the given [`TupleVec`].
    fn dump_vec_ref(&mut self, id: &RelationId, tuples: &(dyn TupleVec + 'static)) {
        self.dump_iter(id, tuples.iter_tuples())
    }

    /// Dumps the contents of the given [`TupleVec`], but takes ownership of it.
    fn dump_vec_owned(&mut self, id: &RelationId, tuples: Box<dyn TupleVec>) {
        self.dump_iter(id, tuples.iter_tuples())
    }
}

impl<D: Dumper> Dumper for &'_ mut D {
    fn dump_iter(&mut self, id: &RelationId, tuples: Box<dyn TupleIter<'_> + '_>) {
        D::dump_iter(*self, id, tuples);
    }

    fn prefer_vec_owned(&self, id: &RelationId) -> bool {
        D::prefer_vec_owned(self, id)
    }

    fn dump_vec_ref(&mut self, id: &RelationId, tuples: &(dyn TupleVec + 'static)) {
        D::dump_vec_ref(*self, id, tuples);
    }

    fn dump_vec_owned(&mut self, id: &RelationId, tuples: Box<dyn TupleVec>) {
        D::dump_vec_owned(*self, id, tuples);
    }
}

/// Log the size of each intermediate relation.
#[derive(Debug)]
pub struct Counts;

impl Dumper for Counts {
    fn dump_iter(&mut self, id: &RelationId, tuples: Box<dyn TupleIter<'_> + '_>) {
        let count = tuples.count();
        info!("\t|{}.{}| = {}", id.unit_name(), id.relation_name(), count);
    }
}
